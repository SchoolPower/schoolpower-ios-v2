// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: powerschool.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Model_Grade {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var percentage: Double = 0

  var letter: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Model_Assignment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var title: String = String()

  var date: Int64 = 0

  var grade: Model_Grade {
    get {return _grade ?? Model_Grade()}
    set {_grade = newValue}
  }
  /// Returns true if `grade` has been explicitly set.
  var hasGrade: Bool {return self._grade != nil}
  /// Clears the value of `grade`. Subsequent reads from it will return its default value.
  mutating func clearGrade() {self._grade = nil}

  var markForDisplay: String = String()

  var category: String = String()

  var includeInFinalGrade: Bool = false

  var weight: Double = 0

  var terms: [String] = []

  var flags: Dictionary<String,Bool> = [:]

  var description_p: String = String()

  var comment: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _grade: Model_Grade? = nil
}

struct Model_TermGrade {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var term: String = String()

  var grade: Model_Grade {
    get {return _grade ?? Model_Grade()}
    set {_grade = newValue}
  }
  /// Returns true if `grade` has been explicitly set.
  var hasGrade: Bool {return self._grade != nil}
  /// Clears the value of `grade`. Subsequent reads from it will return its default value.
  mutating func clearGrade() {self._grade = nil}

  var comment: String = String()

  var evaluation: String = String()

  var evaluationCode: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _grade: Model_Grade? = nil
}

struct Model_Course {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var instructor: String = String()

  var instructorEmail: String = String()

  var block: String = String()

  var room: String = String()

  var assignments: [Model_Assignment] = []

  var grades: [Model_TermGrade] = []

  var startDate: Int64 = 0

  var endDate: Int64 = 0

  var schedule: [Model_Course.Schedule] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Schedule {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var startTime: Int64 = 0

    var endTime: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct Model_Profile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var gpa: Double = 0

  var id: Int32 = 0

  var gender: Model_Profile.Gender = .male

  var dob: Int64 = 0

  var firstName: String = String()

  var middleName: String = String()

  var lastName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Gender: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case male // = 0
    case female // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .male
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .male
      case 1: self = .female
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .male: return 0
      case .female: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Model_Profile.Gender: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Model_Profile.Gender] = [
    .male,
    .female,
  ]
}

#endif  // swift(>=4.2)

struct Model_DisabledInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var title: String = String()

  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Model_ExtraInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var avatarURL: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Model_Attendance {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var code: String = String()

  var date: Int64 = 0

  var description_p: String = String()

  var courseName: String = String()

  var courseBlock: String = String()

  var comment: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Model_StudentData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var profile: Model_Profile {
    get {return _profile ?? Model_Profile()}
    set {_profile = newValue}
  }
  /// Returns true if `profile` has been explicitly set.
  var hasProfile: Bool {return self._profile != nil}
  /// Clears the value of `profile`. Subsequent reads from it will return its default value.
  mutating func clearProfile() {self._profile = nil}

  var attendances: [Model_Attendance] = []

  var courses: [Model_Course] = []

  var disabledInfo: Model_DisabledInfo {
    get {return _disabledInfo ?? Model_DisabledInfo()}
    set {_disabledInfo = newValue}
  }
  /// Returns true if `disabledInfo` has been explicitly set.
  var hasDisabledInfo: Bool {return self._disabledInfo != nil}
  /// Clears the value of `disabledInfo`. Subsequent reads from it will return its default value.
  mutating func clearDisabledInfo() {self._disabledInfo = nil}

  var extraInfo: Model_ExtraInfo {
    get {return _extraInfo ?? Model_ExtraInfo()}
    set {_extraInfo = newValue}
  }
  /// Returns true if `extraInfo` has been explicitly set.
  var hasExtraInfo: Bool {return self._extraInfo != nil}
  /// Clears the value of `extraInfo`. Subsequent reads from it will return its default value.
  mutating func clearExtraInfo() {self._extraInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _profile: Model_Profile? = nil
  fileprivate var _disabledInfo: Model_DisabledInfo? = nil
  fileprivate var _extraInfo: Model_ExtraInfo? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "model"

extension Model_Grade: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Grade"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "percentage"),
    2: .same(proto: "letter"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.percentage) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.letter) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.percentage != 0 {
      try visitor.visitSingularDoubleField(value: self.percentage, fieldNumber: 1)
    }
    if !self.letter.isEmpty {
      try visitor.visitSingularStringField(value: self.letter, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Model_Grade, rhs: Model_Grade) -> Bool {
    if lhs.percentage != rhs.percentage {return false}
    if lhs.letter != rhs.letter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Model_Assignment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Assignment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "date"),
    3: .same(proto: "grade"),
    4: .same(proto: "markForDisplay"),
    6: .same(proto: "category"),
    7: .same(proto: "includeInFinalGrade"),
    8: .same(proto: "weight"),
    9: .same(proto: "terms"),
    10: .same(proto: "flags"),
    11: .same(proto: "description"),
    12: .same(proto: "comment"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.date) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._grade) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.markForDisplay) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.category) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.includeInFinalGrade) }()
      case 8: try { try decoder.decodeSingularDoubleField(value: &self.weight) }()
      case 9: try { try decoder.decodeRepeatedStringField(value: &self.terms) }()
      case 10: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufBool>.self, value: &self.flags) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.comment) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if self.date != 0 {
      try visitor.visitSingularInt64Field(value: self.date, fieldNumber: 2)
    }
    try { if let v = self._grade {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.markForDisplay.isEmpty {
      try visitor.visitSingularStringField(value: self.markForDisplay, fieldNumber: 4)
    }
    if !self.category.isEmpty {
      try visitor.visitSingularStringField(value: self.category, fieldNumber: 6)
    }
    if self.includeInFinalGrade != false {
      try visitor.visitSingularBoolField(value: self.includeInFinalGrade, fieldNumber: 7)
    }
    if self.weight != 0 {
      try visitor.visitSingularDoubleField(value: self.weight, fieldNumber: 8)
    }
    if !self.terms.isEmpty {
      try visitor.visitRepeatedStringField(value: self.terms, fieldNumber: 9)
    }
    if !self.flags.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufBool>.self, value: self.flags, fieldNumber: 10)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 11)
    }
    if !self.comment.isEmpty {
      try visitor.visitSingularStringField(value: self.comment, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Model_Assignment, rhs: Model_Assignment) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.date != rhs.date {return false}
    if lhs._grade != rhs._grade {return false}
    if lhs.markForDisplay != rhs.markForDisplay {return false}
    if lhs.category != rhs.category {return false}
    if lhs.includeInFinalGrade != rhs.includeInFinalGrade {return false}
    if lhs.weight != rhs.weight {return false}
    if lhs.terms != rhs.terms {return false}
    if lhs.flags != rhs.flags {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.comment != rhs.comment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Model_TermGrade: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TermGrade"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "term"),
    2: .same(proto: "grade"),
    3: .same(proto: "comment"),
    4: .same(proto: "evaluation"),
    5: .same(proto: "evaluationCode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.term) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._grade) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.comment) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.evaluation) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.evaluationCode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.term.isEmpty {
      try visitor.visitSingularStringField(value: self.term, fieldNumber: 1)
    }
    try { if let v = self._grade {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.comment.isEmpty {
      try visitor.visitSingularStringField(value: self.comment, fieldNumber: 3)
    }
    if !self.evaluation.isEmpty {
      try visitor.visitSingularStringField(value: self.evaluation, fieldNumber: 4)
    }
    if !self.evaluationCode.isEmpty {
      try visitor.visitSingularStringField(value: self.evaluationCode, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Model_TermGrade, rhs: Model_TermGrade) -> Bool {
    if lhs.term != rhs.term {return false}
    if lhs._grade != rhs._grade {return false}
    if lhs.comment != rhs.comment {return false}
    if lhs.evaluation != rhs.evaluation {return false}
    if lhs.evaluationCode != rhs.evaluationCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Model_Course: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Course"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "instructor"),
    3: .same(proto: "instructorEmail"),
    4: .same(proto: "block"),
    5: .same(proto: "room"),
    6: .same(proto: "assignments"),
    7: .same(proto: "grades"),
    8: .same(proto: "startDate"),
    9: .same(proto: "endDate"),
    10: .same(proto: "schedule"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.instructor) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.instructorEmail) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.block) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.room) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.assignments) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.grades) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.startDate) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.endDate) }()
      case 10: try { try decoder.decodeRepeatedMessageField(value: &self.schedule) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.instructor.isEmpty {
      try visitor.visitSingularStringField(value: self.instructor, fieldNumber: 2)
    }
    if !self.instructorEmail.isEmpty {
      try visitor.visitSingularStringField(value: self.instructorEmail, fieldNumber: 3)
    }
    if !self.block.isEmpty {
      try visitor.visitSingularStringField(value: self.block, fieldNumber: 4)
    }
    if !self.room.isEmpty {
      try visitor.visitSingularStringField(value: self.room, fieldNumber: 5)
    }
    if !self.assignments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.assignments, fieldNumber: 6)
    }
    if !self.grades.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.grades, fieldNumber: 7)
    }
    if self.startDate != 0 {
      try visitor.visitSingularInt64Field(value: self.startDate, fieldNumber: 8)
    }
    if self.endDate != 0 {
      try visitor.visitSingularInt64Field(value: self.endDate, fieldNumber: 9)
    }
    if !self.schedule.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.schedule, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Model_Course, rhs: Model_Course) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.instructor != rhs.instructor {return false}
    if lhs.instructorEmail != rhs.instructorEmail {return false}
    if lhs.block != rhs.block {return false}
    if lhs.room != rhs.room {return false}
    if lhs.assignments != rhs.assignments {return false}
    if lhs.grades != rhs.grades {return false}
    if lhs.startDate != rhs.startDate {return false}
    if lhs.endDate != rhs.endDate {return false}
    if lhs.schedule != rhs.schedule {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Model_Course.Schedule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Model_Course.protoMessageName + ".Schedule"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "startTime"),
    2: .same(proto: "endTime"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.startTime) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.endTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.startTime != 0 {
      try visitor.visitSingularInt64Field(value: self.startTime, fieldNumber: 1)
    }
    if self.endTime != 0 {
      try visitor.visitSingularInt64Field(value: self.endTime, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Model_Course.Schedule, rhs: Model_Course.Schedule) -> Bool {
    if lhs.startTime != rhs.startTime {return false}
    if lhs.endTime != rhs.endTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Model_Profile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Profile"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gpa"),
    2: .same(proto: "id"),
    3: .same(proto: "gender"),
    4: .same(proto: "dob"),
    5: .same(proto: "firstName"),
    6: .same(proto: "middleName"),
    7: .same(proto: "lastName"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.gpa) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.gender) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.dob) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.firstName) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.middleName) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.lastName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.gpa != 0 {
      try visitor.visitSingularDoubleField(value: self.gpa, fieldNumber: 1)
    }
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 2)
    }
    if self.gender != .male {
      try visitor.visitSingularEnumField(value: self.gender, fieldNumber: 3)
    }
    if self.dob != 0 {
      try visitor.visitSingularInt64Field(value: self.dob, fieldNumber: 4)
    }
    if !self.firstName.isEmpty {
      try visitor.visitSingularStringField(value: self.firstName, fieldNumber: 5)
    }
    if !self.middleName.isEmpty {
      try visitor.visitSingularStringField(value: self.middleName, fieldNumber: 6)
    }
    if !self.lastName.isEmpty {
      try visitor.visitSingularStringField(value: self.lastName, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Model_Profile, rhs: Model_Profile) -> Bool {
    if lhs.gpa != rhs.gpa {return false}
    if lhs.id != rhs.id {return false}
    if lhs.gender != rhs.gender {return false}
    if lhs.dob != rhs.dob {return false}
    if lhs.firstName != rhs.firstName {return false}
    if lhs.middleName != rhs.middleName {return false}
    if lhs.lastName != rhs.lastName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Model_Profile.Gender: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MALE"),
    1: .same(proto: "FEMALE"),
  ]
}

extension Model_DisabledInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DisabledInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Model_DisabledInfo, rhs: Model_DisabledInfo) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Model_ExtraInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExtraInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "avatarUrl"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.avatarURL) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Model_ExtraInfo, rhs: Model_ExtraInfo) -> Bool {
    if lhs.avatarURL != rhs.avatarURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Model_Attendance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Attendance"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "date"),
    3: .same(proto: "description"),
    4: .same(proto: "courseName"),
    5: .same(proto: "courseBlock"),
    6: .same(proto: "comment"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.date) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.courseName) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.courseBlock) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.comment) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.code.isEmpty {
      try visitor.visitSingularStringField(value: self.code, fieldNumber: 1)
    }
    if self.date != 0 {
      try visitor.visitSingularInt64Field(value: self.date, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if !self.courseName.isEmpty {
      try visitor.visitSingularStringField(value: self.courseName, fieldNumber: 4)
    }
    if !self.courseBlock.isEmpty {
      try visitor.visitSingularStringField(value: self.courseBlock, fieldNumber: 5)
    }
    if !self.comment.isEmpty {
      try visitor.visitSingularStringField(value: self.comment, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Model_Attendance, rhs: Model_Attendance) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.date != rhs.date {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.courseName != rhs.courseName {return false}
    if lhs.courseBlock != rhs.courseBlock {return false}
    if lhs.comment != rhs.comment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Model_StudentData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StudentData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "profile"),
    2: .same(proto: "attendances"),
    3: .same(proto: "courses"),
    4: .same(proto: "disabledInfo"),
    5: .same(proto: "extraInfo"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._profile) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.attendances) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.courses) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._disabledInfo) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._extraInfo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._profile {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.attendances.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attendances, fieldNumber: 2)
    }
    if !self.courses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.courses, fieldNumber: 3)
    }
    try { if let v = self._disabledInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._extraInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Model_StudentData, rhs: Model_StudentData) -> Bool {
    if lhs._profile != rhs._profile {return false}
    if lhs.attendances != rhs.attendances {return false}
    if lhs.courses != rhs.courses {return false}
    if lhs._disabledInfo != rhs._disabledInfo {return false}
    if lhs._extraInfo != rhs._extraInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
